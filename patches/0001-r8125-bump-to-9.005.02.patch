From 9ab352855351862a0d75d36aabeb30ccca2d0228 Mon Sep 17 00:00:00 2001
From: root <root@Debian.gzxhwq.eu.org>
Date: Thu, 4 Mar 2021 12:28:59 +0000
Subject: [PATCH 1/2] r8125: bump to 9.005.02

---
 package/lean/r8125/Makefile        |   2 +-
 package/lean/r8125/src/Makefile    |   2 +-
 package/lean/r8125/src/r8125.h     |   7 +-
 package/lean/r8125/src/r8125_lib.c | 656 +++++++++++++++++++++++++++++
 package/lean/r8125/src/r8125_lib.h | 204 +++++++++
 package/lean/r8125/src/r8125_n.c   | 160 +++++--
 6 files changed, 990 insertions(+), 41 deletions(-)
 create mode 100644 package/lean/r8125/src/r8125_lib.c
 create mode 100644 package/lean/r8125/src/r8125_lib.h

diff --git a/package/lean/r8125/Makefile b/package/lean/r8125/Makefile
index 3e4f3af4c..8d43d49b8 100755
--- a/package/lean/r8125/Makefile
+++ b/package/lean/r8125/Makefile
@@ -65,7 +65,7 @@ include $(TOPDIR)/rules.mk
 include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=r8125
-PKG_VERSION:=9.005.01
+PKG_VERSION:=9.005.02
 PKG_RELEASE:=1
 
 #PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
diff --git a/package/lean/r8125/src/Makefile b/package/lean/r8125/src/Makefile
index 067419095..e73b1a8bb 100755
--- a/package/lean/r8125/src/Makefile
+++ b/package/lean/r8125/src/Makefile
@@ -45,7 +45,7 @@ ENABLE_MULTIPLE_TX_QUEUE = n
 ENABLE_PTP_SUPPORT = n
 ENABLE_PTP_MASTER_MODE = n
 ENABLE_RSS_SUPPORT = y
-ENABLE_LIB_SUPPORT = n
+ENABLE_LIB_SUPPORT = y
 
 ifneq ($(KERNELRELEASE),)
 	obj-m := r8125.o
diff --git a/package/lean/r8125/src/r8125.h b/package/lean/r8125/src/r8125.h
index 06893797b..6d4f334b7 100755
--- a/package/lean/r8125/src/r8125.h
+++ b/package/lean/r8125/src/r8125.h
@@ -357,7 +357,7 @@ do { \
 #define RSS_SUFFIX ""
 #endif
 
-#define RTL8125_VERSION "9.005.01" NAPI_SUFFIX DASH_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
+#define RTL8125_VERSION "9.005.02" NAPI_SUFFIX DASH_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
 #define MODULENAME "r8125"
 #define PFX MODULENAME ": "
 
@@ -1931,6 +1931,8 @@ struct rtl8125_private {
         u8 HwSuppD0SpeedUpVer;
         u8 D0SpeedUpSpeed;
 
+        u8 ring_lib_enabled;
+
         //Dash+++++++++++++++++
         u8 HwSuppDashVer;
         u8 DASH;
@@ -2020,8 +2022,7 @@ struct rtl8125_private {
         //Realwow--------------
 #endif //ENABLE_REALWOW_SUPPORT
 
-        u32 eee_adv_t;
-        u8 eee_enabled;
+        struct ethtool_eee eee;
 
 #ifdef ENABLE_R8125_PROCFS
         //Procfs support
diff --git a/package/lean/r8125/src/r8125_lib.c b/package/lean/r8125/src/r8125_lib.c
new file mode 100644
index 000000000..ea2e86cff
--- /dev/null
+++ b/package/lean/r8125/src/r8125_lib.c
@@ -0,0 +1,656 @@
+/*
+################################################################################
+#
+# r8168 is the Linux device driver released for Realtek Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2020 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/pci.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include "r8125.h"
+#include "r8125_lib.h"
+
+static void
+rtl8125_map_to_asic(struct rtl8125_private *tp,
+                    struct rtl8125_ring *ring,
+                    struct RxDesc *desc,
+                    dma_addr_t mapping,
+                    u32 rx_buf_sz,
+                    const u32 cur_rx)
+{
+        ring->bufs[cur_rx].dma_addr = mapping;
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                ((struct RxDescV3 *)desc)->addr = cpu_to_le64(mapping);
+        else
+                desc->addr = cpu_to_le64(mapping);
+        wmb();
+        rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
+}
+
+static void
+rtl8125_lib_tx_fill(struct rtl8125_ring *ring)
+{
+        struct TxDesc *descs = ring->desc_addr;
+        u32 i;
+
+        for (i = 0; i < ring->ring_size; i++) {
+                struct TxDesc *desc = &descs[i];
+
+                desc->addr = cpu_to_le64(ring->bufs[i].dma_addr);
+
+                if (i == (ring->ring_size - 1))
+                        desc->opts1 = cpu_to_le32(RingEnd);
+        }
+}
+
+static inline void
+rtl8125_mark_as_last_descriptor_8125(struct RxDescV3 *descv3)
+{
+        descv3->RxDescNormalDDWord4.opts1 |= cpu_to_le32(RingEnd);
+}
+
+static inline void
+rtl8125_mark_as_last_descriptor(struct rtl8125_private *tp,
+                                struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                rtl8125_mark_as_last_descriptor_8125((struct RxDescV3 *)desc);
+        else
+                desc->opts1 |= cpu_to_le32(RingEnd);
+}
+
+static void
+rtl8125_lib_rx_fill(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp = ring->private;
+        struct RxDesc *desc;
+        u32 i;
+
+        for (i = 0; i < ring->ring_size; i++) {
+                desc = rtl8125_get_rxdesc(tp, ring->desc_addr, i);
+                rtl8125_map_to_asic(tp, ring, desc,
+                                    ring->bufs[i].dma_addr, ring->buff_size, i);
+        }
+
+        rtl8125_mark_as_last_descriptor(tp,
+                                        rtl8125_get_rxdesc(tp, ring->desc_addr, ring->ring_size - 1));
+}
+
+struct rtl8125_ring *rtl8125_get_tx_ring(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = tp->num_tx_rings; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_tx_ring[i];
+                if (!ring->allocated) {
+                        ring->allocated = true;
+                        return ring;
+                }
+        }
+
+        return NULL;
+}
+
+struct rtl8125_ring *rtl8125_get_rx_ring(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = tp->num_rx_rings; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_rx_ring[i];
+                if (!ring->allocated) {
+                        ring->allocated = true;
+                        return ring;
+                }
+        }
+
+        return NULL;
+}
+
+static void rtl8125_put_ring(struct rtl8125_ring *ring)
+{
+        if (!ring)
+                return;
+
+        ring->allocated = false;
+}
+
+static void rtl8125_init_rx_ring(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp = ring->private;
+
+        if (!ring->allocated)
+                return;
+
+        rtl8125_lib_rx_fill(ring);
+
+        RTL_W32(tp, RDSAR_Q1_LOW_8125, ((u64)ring->desc_daddr & DMA_BIT_MASK(32)));
+        RTL_W32(tp, RDSAR_Q1_LOW_8125 + 4, ((u64)ring->desc_daddr >> 32));
+}
+
+static void rtl8125_init_tx_ring(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp = ring->private;
+
+        if (!ring->allocated)
+                return;
+
+        rtl8125_lib_tx_fill(ring);
+
+        RTL_W32(tp, TNPDS_Q1_LOW_8125, ((u64)ring->desc_daddr & DMA_BIT_MASK(32)));
+        RTL_W32(tp, TNPDS_Q1_LOW_8125 + 4, ((u64)ring->desc_daddr >> 32));
+}
+
+static void rtl8125_free_ring_mem(struct rtl8125_ring *ring)
+{
+        unsigned i;
+        struct rtl8125_private *tp = ring->private;
+        struct pci_dev *pdev = tp->pci_dev;
+
+        if (ring->desc_addr) {
+                dma_free_coherent(&pdev->dev, ring->desc_size,
+                                  ring->desc_addr, ring->desc_daddr);
+
+                ring->desc_addr = NULL;
+        }
+
+        if (ring->flags & RTL8125_CONTIG_BUFS) {
+                struct rtl8125_buf *rtl_buf = &ring->bufs[0];
+                dma_free_coherent(
+                        &pdev->dev,
+                        ring->ring_size * ring->buff_size,
+                        rtl_buf->addr,
+                        rtl_buf->dma_addr);
+        } else {
+                for (i=0; i<ring->ring_size ; i++) {
+                        struct rtl8125_buf *rtl_buf = &ring->bufs[i];
+                        if (rtl_buf->addr) {
+                                dma_free_coherent(
+                                        &pdev->dev,
+                                        rtl_buf->size,
+                                        rtl_buf->addr,
+                                        rtl_buf->dma_addr);
+
+                                rtl_buf->addr = NULL;
+                        }
+                }
+        }
+
+        if (ring->bufs) {
+                kfree(ring->bufs);
+                ring->bufs = 0;
+        }
+}
+
+static int rtl8125_alloc_ring_mem(struct rtl8125_ring *ring)
+{
+        int i;
+        struct rtl8125_private *tp = ring->private;
+        struct pci_dev *pdev = tp->pci_dev;
+
+        ring->bufs = kzalloc(sizeof(struct rtl8125_buf) * ring->ring_size, GFP_KERNEL);
+        if (!ring->bufs)
+                return -ENOMEM;
+
+        if (ring->mem_ops == NULL) {
+                /* Use dma_alloc_coherent() and dma_free_coherent() below */
+                if (ring->direction == RTL8125_CH_DIR_TX)
+                        ring->desc_size = ring->ring_size * sizeof(struct TxDesc);
+                else if (ring->direction == RTL8125_CH_DIR_RX)
+                        ring->desc_size = ring->ring_size * tp->RxDescLength;
+
+                ring->desc_addr = dma_alloc_coherent(
+                                          &pdev->dev,
+                                          ring->desc_size,
+                                          &ring->desc_daddr,
+                                          GFP_KERNEL);
+                if (!ring->desc_addr)
+                        goto error_out;
+
+                memset(ring->desc_addr, 0x0, ring->desc_size);
+
+                if (ring->flags & RTL8125_CONTIG_BUFS) {
+                        struct rtl8125_buf *rtl_buf = &ring->bufs[0];
+
+                        rtl_buf->size = ring->buff_size;
+                        rtl_buf->addr = dma_alloc_coherent(
+                                                &pdev->dev,
+                                                ring->ring_size * ring->buff_size,
+                                                &rtl_buf->dma_addr,
+                                                GFP_KERNEL);
+                        if (!rtl_buf->addr)
+                                goto error_out;
+
+                        for (i = 1; i < ring->ring_size; i++) {
+                                struct rtl8125_buf *rtl_buf = &ring->bufs[i];
+                                struct rtl8125_buf *rtl_buf_prev = &ring->bufs[i-1];
+                                rtl_buf->size = ring->buff_size;
+                                rtl_buf->addr = rtl_buf_prev->addr + ring->buff_size;
+                                rtl_buf->dma_addr = rtl_buf_prev->dma_addr + ring->buff_size;
+                        }
+
+                } else {
+                        for (i = 0; i < ring->ring_size; i++) {
+                                struct rtl8125_buf *rtl_buf = &ring->bufs[i];
+
+                                rtl_buf->size = ring->buff_size;
+                                rtl_buf->addr = dma_alloc_coherent(
+                                                        &pdev->dev,
+                                                        rtl_buf->size,
+                                                        &rtl_buf->dma_addr,
+                                                        GFP_KERNEL);
+                                if (!rtl_buf->addr)
+                                        goto error_out;
+
+                                memset(rtl_buf->addr, 0x0, rtl_buf->size);
+                        }
+                }
+        }
+#if 0
+        /* Validate parameters */
+        /* Allocate descs */
+        mem_ops->alloc_descs(...);
+
+        /* Allocate buffers */
+        if (R8125B_CONTIG_BUFS) {
+                mem_ops->alloc_buffs(...);
+        } else {
+                /* Call mem_ops->alloc_buffs(...) for each descriptor. */
+        }
+#endif
+
+        return 0;
+
+error_out:
+
+        rtl8125_free_ring_mem(ring);
+
+        return -ENOMEM;
+}
+
+
+struct rtl8125_ring *rtl8125_request_ring(struct net_device *ndev,
+                unsigned int ring_size, unsigned int buff_size,
+                enum rtl8125_channel_dir direction, unsigned int flags,
+                struct rtl8125_mem_ops *mem_ops)
+{
+        struct rtl8125_private *tp = netdev_priv(ndev);
+        struct rtl8125_ring * ring = 0;
+
+        if (direction == RTL8125_CH_DIR_TX) {
+                ring = rtl8125_get_tx_ring(tp);
+                if (!ring)
+                        goto error_out;
+        } else if (direction == RTL8125_CH_DIR_RX) {
+                ring = rtl8125_get_rx_ring(tp);
+                if (!ring)
+                        goto error_out;
+        } else
+                goto error_out;
+
+        ring->ring_size = ring_size;
+        ring->buff_size = buff_size;
+        ring->mem_ops = mem_ops;
+        ring->flags = flags;
+
+        if (rtl8125_alloc_ring_mem(ring))
+                goto error_out;
+
+        /* initialize descriptors to point to buffers allocated */
+        if (direction == RTL8125_CH_DIR_TX)
+                rtl8125_init_tx_ring(ring);
+        else if (direction == RTL8125_CH_DIR_RX)
+                rtl8125_init_rx_ring(ring);
+
+        return ring;
+
+error_out:
+        rtl8125_free_ring_mem(ring);
+        rtl8125_put_ring(ring);
+
+        return NULL;
+}
+EXPORT_SYMBOL(rtl8125_request_ring);
+
+void rtl8125_release_ring(struct rtl8125_ring *ring)
+{
+        if (!ring)
+                return;
+
+        rtl8125_free_ring_mem(ring);
+        rtl8125_put_ring(ring);
+}
+EXPORT_SYMBOL(rtl8125_release_ring);
+
+void
+rtl8125_hw_config(struct net_device *dev);
+
+int rtl8125_enable_ring(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp;
+        struct net_device *dev;
+
+        if (!ring)
+                return -EINVAL;
+
+        if (!(ring->direction == RTL8125_CH_DIR_TX || ring->direction == RTL8125_CH_DIR_RX))
+                return -EINVAL;
+
+        tp = ring->private;
+        dev = tp->dev;
+
+        /* Start the ring if needed */
+        rtl8125_hw_reset(dev);
+        rtl8125_tx_clear(tp);
+        rtl8125_rx_clear(tp);
+        rtl8125_init_ring(dev);
+
+        ring->enabled = true;
+
+        rtl8125_hw_config(dev);
+        rtl8125_hw_start(dev);
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_enable_ring);
+
+void rtl8125_disable_ring(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp;
+        struct net_device *dev;
+
+        /* Stop the ring if possible. IPA do not want to receive or transmit
+        packets beyond this point.
+        */
+
+        if (!ring)
+                return;
+
+        if (!(ring->direction == RTL8125_CH_DIR_TX || ring->direction == RTL8125_CH_DIR_RX))
+                return;
+
+        tp = ring->private;
+        dev = tp->dev;
+
+        rtl8125_hw_reset(dev);
+        rtl8125_tx_clear(tp);
+        rtl8125_rx_clear(tp);
+        rtl8125_init_ring(dev);
+
+        ring->enabled = false;
+
+        rtl8125_hw_config(dev);
+        rtl8125_hw_start(dev);
+}
+EXPORT_SYMBOL(rtl8125_disable_ring);
+
+int rtl8125_request_event(struct rtl8125_ring *ring, unsigned long flags,
+                          dma_addr_t addr, u64 data)
+{
+        struct rtl8125_private *tp;
+        struct pci_dev *pdev;
+        u32 message_id;
+
+        if (!ring)
+                return -EINVAL;
+
+        if (!(ring->direction == RTL8125_CH_DIR_TX || ring->direction == RTL8125_CH_DIR_RX))
+                return -EINVAL;
+
+        if (ring->event.allocated)
+                return -EEXIST;
+
+        if (ring->direction == RTL8125_CH_DIR_TX)
+                message_id = (ring->queue_num == 0 ? 16 : 18);
+        else
+                message_id = ring->queue_num;
+
+        tp = ring->private;
+        pdev = tp->pci_dev;
+
+        if (flags & MSIX_event_type) {
+                /* Update MSI-X table entry with @addr and @data */
+                /* Initialize any MSI-X/interrupt related register in HW */
+                u16 reg = message_id * 0x10;
+
+                ring->event.addr = rtl8125_eri_read(tp, reg, 4, ERIAR_MSIX);
+                ring->event.addr |= (u64)rtl8125_eri_read(tp, reg + 4, 4, ERIAR_MSIX) << 32;
+                ring->event.data = rtl8125_eri_read(tp, reg + 8, 4, ERIAR_MSIX);
+                ring->event.data |= (u64)rtl8125_eri_read(tp, reg + 8, 4, ERIAR_MSIX) << 32;
+
+                rtl8125_eri_write(tp, reg, 4, (u64)addr & DMA_BIT_MASK(32), ERIAR_MSIX);
+                rtl8125_eri_write(tp, reg + 4, 4, (u64)addr >> 32, ERIAR_MSIX);
+                rtl8125_eri_write(tp, reg + 8, 4, data, ERIAR_MSIX);
+                rtl8125_eri_write(tp, reg + 12, 4, data >> 32, ERIAR_MSIX);
+
+                ring->event.message_id = message_id;
+                ring->event.allocated = 1;
+        }
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_request_event);
+
+void rtl8125_release_event(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp;
+        dma_addr_t addr;
+        u64 data;
+        u16 reg;
+
+        /* Reverse request_event() */
+        if (!ring->event.allocated)
+                return;
+
+        if (!(ring->direction == RTL8125_CH_DIR_TX || ring->direction == RTL8125_CH_DIR_RX))
+                return;
+
+        if (!ring->event.allocated)
+                return;
+
+        tp = ring->private;
+
+        reg = ring->event.message_id * 0x10;
+
+        addr = ring->event.addr;
+        data = ring->event.data;
+        rtl8125_eri_write(tp, reg, 4, (u64)addr & DMA_BIT_MASK(32), ERIAR_MSIX);
+        rtl8125_eri_write(tp, reg + 4, 4, (u64)addr >> 32, ERIAR_MSIX);
+        rtl8125_eri_write(tp, reg + 8, 4, data, ERIAR_MSIX);
+        rtl8125_eri_write(tp, reg + 12, 4, data >> 32, ERIAR_MSIX);
+
+        ring->event.allocated = 0;
+
+        return;
+}
+EXPORT_SYMBOL(rtl8125_release_event);
+
+int rtl8125_enable_event(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp = ring->private;
+
+        if (!ring->event.allocated)
+                return -EINVAL;
+
+        /* Set interrupt moderation timer */
+        rtl8125_set_ring_intr_mod(ring, ring->event.delay);
+
+        /* Enable interrupt */
+        rtl8125_enable_hw_interrupt_v2(tp, ring->event.message_id);
+
+        ring->event.enabled = 1;
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_enable_event);
+
+int rtl8125_disable_event(struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp = ring->private;
+
+        if (!ring->event.allocated)
+                return -EINVAL;
+
+        /* Disable interrupt */
+        rtl8125_disable_hw_interrupt_v2(tp, ring->event.message_id);
+
+        ring->event.enabled = 0;
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_disable_event);
+
+int rtl8125_set_ring_intr_mod(struct rtl8125_ring *ring, int delay)
+{
+        struct rtl8125_private *tp = ring->private;
+
+        if (!ring->event.allocated)
+                return -EFAULT;
+
+        ring->event.delay = delay;
+
+        /* Set interrupt moderation timer */
+        rtl8125_hw_set_timer_int_8125(tp, ring->event.message_id, ring->event.delay);
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_set_ring_intr_mod);
+
+int rtl8125_rss_redirect(struct net_device *ndev,
+                         unsigned long flags,
+                         struct rtl8125_ring *ring)
+{
+        struct rtl8125_private *tp = ring->private;
+        int i;
+
+        /* Disable RSS if needed */
+        /* Update RSS hash table to set all entries point to ring->queue */
+        /* Set additional flags as needed. Ex. hash_type */
+        /* Enable RSS */
+
+        for (i = 0; i < rtl8125_rss_indir_tbl_entries(tp); i++)
+                tp->rss_indir_tbl[i] = ring->queue_num;
+
+        _rtl8125_config_rss(tp);
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_rss_redirect);
+
+int rtl8125_rss_reset(struct net_device *ndev)
+{
+        struct rtl8125_private *tp = netdev_priv(ndev);
+
+        /* Disable RSS */
+        /* Reset RSS hash table */
+        /* Enable RSS if that is the default config for driver */
+
+        rtl8125_init_rss(tp);
+        _rtl8125_config_rss(tp);
+
+        return 0;
+}
+EXPORT_SYMBOL(rtl8125_rss_reset);
+
+struct net_device *rtl8125_get_netdev(struct device *dev)
+{
+        struct pci_dev *pdev = to_pci_dev(dev);
+
+        /* Get device private data from @dev */
+        /* Retrieve struct net_device * from device private data */
+
+        return pci_get_drvdata(pdev);
+}
+EXPORT_SYMBOL(rtl8125_get_netdev);
+
+int rtl8125_receive_skb(struct net_device *net_dev, struct sk_buff *skb, bool napi)
+{
+        /* Update interface stats - rx_packets, rx_bytes */
+        skb->protocol = eth_type_trans(skb, net_dev);
+        return napi ? netif_receive_skb(skb) : netif_rx(skb);
+}
+EXPORT_SYMBOL(rtl8125_receive_skb);
+
+int rtl8125_register_notifier(struct net_device *net_dev,
+                              struct notifier_block *nb)
+{
+        struct rtl8125_private *tp = netdev_priv(net_dev);
+
+        return atomic_notifier_chain_register(&tp->lib_nh, nb);
+}
+EXPORT_SYMBOL(rtl8125_register_notifier);
+
+int rtl8125_unregister_notifier(struct net_device *net_dev,
+                                struct notifier_block *nb)
+{
+        struct rtl8125_private *tp = netdev_priv(net_dev);
+
+        return atomic_notifier_chain_unregister(&tp->lib_nh, nb);
+}
+EXPORT_SYMBOL(rtl8125_unregister_notifier);
+
+void rtl8125_lib_reset_prepare(struct rtl8125_private *tp)
+{
+        atomic_notifier_call_chain(&tp->lib_nh,
+                                   RTL8125_NOTIFY_RESET_PREPARE, NULL);
+}
+EXPORT_SYMBOL(rtl8125_lib_reset_prepare);
+
+void rtl8125_lib_reset_complete(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_tx_ring[i];
+
+                if (!ring->allocated)
+                        continue;
+
+                if (ring->event.enabled)
+                        rtl8125_enable_event(ring);
+
+                rtl8125_init_tx_ring(ring);
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_rx_ring[i];
+
+                if (!ring->allocated)
+                        continue;
+
+                if (ring->event.enabled)
+                        rtl8125_enable_event(ring);
+
+                rtl8125_init_rx_ring(ring);
+        }
+
+        atomic_notifier_call_chain(&tp->lib_nh,
+                                   RTL8125_NOTIFY_RESET_COMPLETE, NULL);
+}
+EXPORT_SYMBOL(rtl8125_lib_reset_complete);
diff --git a/package/lean/r8125/src/r8125_lib.h b/package/lean/r8125/src/r8125_lib.h
new file mode 100644
index 000000000..e2e303e8a
--- /dev/null
+++ b/package/lean/r8125/src/r8125_lib.h
@@ -0,0 +1,204 @@
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2020 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_LIB_H
+#define _LINUX_rtl8125_LIB_H
+
+/*
+IPA SW would like to pass its own memory allocators to
+request_ring() to allocate/free the memory for the descriptor ring and buffers.
+
+Private field is needed in allocator.
+Private field will be used by IPA offload software, not to be touched by
+Realtek driver.
+
+Realtek driver can use the allocators similar to dma_alloc_coherent() and
+dma_free_coherent(). Allocator should pass the mem ops as one of the parameters
+for us to access our private data.
+*/
+
+#include <linux/device.h>
+#include <linux/types.h>
+
+struct rtl8125_mem_ops {
+        void *(*alloc_descs)(struct device *dev, size_t size, dma_addr_t *daddr,
+                             gfp_t gfp, struct rtl8125_mem_ops *ops);
+        void *(*alloc_buf)(struct device *dev, size_t size, dma_addr_t *daddr,
+                           gfp_t gfp, struct rtl8125_mem_ops *ops);
+
+        void (*free_descs)(void *buf, struct device *dev, size_t size,
+                           dma_addr_t daddr, struct rtl8125_mem_ops *ops);
+        void (*free_buf)(void *buf, struct device *dev, size_t size,
+                         dma_addr_t daddr, struct rtl8125_mem_ops *ops);
+
+        void *private;
+};
+
+enum rtl8125_channel_dir {
+        RTL8125_CH_DIR_RX,
+        RTL8125_CH_DIR_TX,
+};
+
+enum rtl8125_ring_flags {
+        RTL8125_CONTIG_BUFS = BIT(0), /* Alloc entire ring buffer memory as a contiguous block */
+        RTL8125_NO_CLOSE = BIT(1), /* No Close Feature */
+        /*...*/
+};
+
+/* Represents each buffer allocated */
+struct rtl8125_buf {
+        /* struct list_head bufs_list; */
+        void *addr;
+        dma_addr_t dma_addr;
+        phys_addr_t phys_addr;
+        size_t size;
+};
+
+enum rtl8125_event_flags {
+        /* If any */
+        MSIX_event_type = BIT(0),
+};
+
+struct rtl8125_event {
+        /* MSI vector information as needed */
+        dma_addr_t addr;
+        u64 data;
+        bool allocated;
+        bool enabled;
+        u32 message_id;
+
+        /* Moderation parameters */
+        int delay;
+};
+
+/* Represents ring allocated for IPA */
+struct rtl8125_ring {
+        bool enabled;
+        bool allocated;
+        enum rtl8125_channel_dir direction;
+
+        u32 queue_num;
+        unsigned long flags;
+
+        unsigned ring_size;
+        unsigned desc_size;
+        unsigned buff_size;
+
+        void *desc_addr; /* descriptor base virt addr */
+        dma_addr_t desc_daddr; /* descriptor base dma addr */
+        phys_addr_t desc_paddr; /* descriptor base phys addr */
+
+        /* List or array of buffers allocated. If RTL8125_CONTIG_BUFS was
+          requested, then only one entry need to be populated for the one
+          contiguous buffer.
+         */
+        struct rtl8125_buf *bufs; /* OR struct list_head bufs; */
+
+        struct rtl8125_mem_ops *mem_ops; /* store mem ops to use for freeing */
+
+        /* Other driver fields */
+        struct rtl8125_event event;
+
+        void *private;
+};
+
+enum rtl8125_rss_flags {
+        RTL8125_RSS_HASH_IPV4 = BIT(0),
+        RTL8125_RSS_HASH_IPV6 = BIT(1),
+        /*...*/
+};
+
+enum rtl8125_notify {
+        RTL8125_NOTIFY_RESET_PREPARE,
+        RTL8125_NOTIFY_RESET_COMPLETE,
+};
+
+/* Allocate an Rx or Tx ring */
+struct rtl8125_ring *rtl8125_request_ring(struct net_device *ndev,
+                unsigned int ring_size, unsigned int buff_size,
+                enum rtl8125_channel_dir direction, unsigned int flags,
+                struct rtl8125_mem_ops *mem_ops);
+
+void rtl8125_release_ring(struct rtl8125_ring *ring);
+
+/* Starts the ring */
+int rtl8125_enable_ring(struct rtl8125_ring *ring);
+
+void rtl8125_disable_ring(struct rtl8125_ring *ring);
+
+
+/* Allocate an event (MSI-X, pointer wrb, etc.). Only one type of event will
+be requested from a ring at any point of time.
+*/
+int rtl8125_request_event(struct rtl8125_ring *ring, unsigned long flags,
+                          dma_addr_t addr, u64 data);
+
+void rtl8125_release_event(struct rtl8125_ring *ring);
+
+/* Enables the interrupt */
+int rtl8125_enable_event(struct rtl8125_ring *ring);
+
+int rtl8125_disable_event(struct rtl8125_ring *ring);
+
+
+/* Sets interrupt moderation. Count, Timer, or both. If HW does not suport
+ranges for moderation, one parameter for timer and count is sufficient.*/
+int rtl8125_set_ring_intr_mod(struct rtl8125_ring *ring, int delay);
+
+/* Redirect Rx RSS hash table to a given ring */
+int rtl8125_rss_redirect(struct net_device *ndev,
+                         unsigned long flags,
+                         struct rtl8125_ring *ring);
+
+/* Reset RSS hash table to driver default. IPA will call this only after Rx ring
+ is disabled through disable_ring() API.
+*/
+int rtl8125_rss_reset(struct net_device *ndev);
+
+/* Get net_device object from struct device. */
+struct net_device *rtl8125_get_netdev(struct device *dev);
+
+int rtl8125_receive_skb(struct net_device *net_dev, struct sk_buff *skb,
+                        bool napi);
+
+int rtl8125_register_notifier(struct net_device *net_dev,
+                              struct notifier_block *nb);
+
+int rtl8125_unregister_notifier(struct net_device *net_dev,
+                                struct notifier_block *nb);
+
+void rtl8125_lib_reset_prepare(struct rtl8125_private *tp);
+
+void rtl8125_lib_reset_complete(struct rtl8125_private *tp);
+
+#endif /* _LINUX_rtl8125_LIB_H */
diff --git a/package/lean/r8125/src/r8125_n.c b/package/lean/r8125/src/r8125_n.c
index 608d8c2ee..424881b89 100755
--- a/package/lean/r8125/src/r8125_n.c
+++ b/package/lean/r8125/src/r8125_n.c
@@ -700,7 +700,7 @@ static int proc_get_driver_variable(struct seq_file *m, void *v)
         seq_printf(m, "aspm\t0x%x\n", aspm);
         seq_printf(m, "s5wol\t0x%x\n", s5wol);
         seq_printf(m, "s5_keep_curr_mac\t0x%x\n", s5_keep_curr_mac);
-        seq_printf(m, "eee_enable\t0x%x\n", tp->eee_enabled);
+        seq_printf(m, "eee_enable\t0x%x\n", tp->eee.eee_enabled);
         seq_printf(m, "hwoptimize\t0x%lx\n", hwoptimize);
         seq_printf(m, "proc_init_num\t0x%x\n", proc_init_num);
         seq_printf(m, "s0_magic_packet\t0x%x\n", s0_magic_packet);
@@ -728,6 +728,7 @@ static int proc_get_driver_variable(struct seq_file *m, void *v)
         seq_printf(m, "ptp_master_mode\t0x%x\n", tp->ptp_master_mode);
         seq_printf(m, "min_irq_nvecs\t0x%x\n", tp->min_irq_nvecs);
         seq_printf(m, "irq_nvecs\t0x%x\n", tp->irq_nvecs);
+        seq_printf(m, "ring_lib_enabled\t0x%x\n", tp->ring_lib_enabled);
 #ifdef ENABLE_PTP_SUPPORT
         seq_printf(m, "tx_hwtstamp_timeouts\t0x%x\n", tp->tx_hwtstamp_timeouts);
         seq_printf(m, "tx_hwtstamp_skipped\t0x%x\n", tp->tx_hwtstamp_skipped);
@@ -1061,6 +1062,7 @@ static int proc_get_driver_variable(char *page, char **start,
                         "ptp_master_mode\t0x%x\n"
                         "min_irq_nvecs\t0x%x\n"
                         "irq_nvecs\t0x%x\n"
+                        "ring_lib_enabled\t0x%x\n"
 #ifdef ENABLE_PTP_SUPPORT
                         "tx_hwtstamp_timeouts\t0x%x\n"
                         "tx_hwtstamp_skipped\t0x%x\n"
@@ -1146,7 +1148,7 @@ static int proc_get_driver_variable(char *page, char **start,
                         aspm,
                         s5wol,
                         s5_keep_curr_mac,
-                        tp->eee_enabled,
+                        tp->eee.eee_enabled,
                         hwoptimize,
                         proc_init_num,
                         s0_magic_packet,
@@ -1174,6 +1176,7 @@ static int proc_get_driver_variable(char *page, char **start,
                         tp->ptp_master_mode,
                         tp->min_irq_nvecs,
                         tp->irq_nvecs,
+                        tp->ring_lib_enabled,
 #ifdef ENABLE_PTP_SUPPORT
                         tp->tx_hwtstamp_timeouts,
                         tp->tx_hwtstamp_skipped,
@@ -4433,7 +4436,7 @@ static int rtl8125_hw_set_features(struct net_device *dev,
         else
                 rx_config &= ~(AcceptErr | AcceptRunt);
 
-        if (dev->features & NETIF_F_HW_VLAN_RX)
+        if (features & NETIF_F_HW_VLAN_RX)
                 rx_config |= (EnableInnerVlan | EnableOuterVlan);
         else
                 rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
@@ -4909,17 +4912,21 @@ static int _kc_ethtool_op_set_sg(struct net_device *dev, u32 data)
 
 static int rtl8125_enable_eee(struct rtl8125_private *tp)
 {
+        struct ethtool_eee *eee = &tp->eee;
+        u16 eee_adv_t = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
         int ret;
 
         ret = 0;
         switch (tp->mcfg) {
         case CFG_METHOD_2:
         case CFG_METHOD_3:
+                RTL_W16(tp, EEE_TXIDLE_TIMER_8125, eee->tx_lpi_timer);
+
                 SetMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
                 SetMcuAccessRegBit(tp, 0xEB62, (BIT_2|BIT_1));
 
                 SetEthPhyOcpBit(tp, 0xA432, BIT_4);
-                SetEthPhyOcpBit(tp, 0xA5D0, tp->eee_adv_t);
+                SetEthPhyOcpBit(tp, 0xA5D0, eee_adv_t);
                 ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
 
                 ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
@@ -4928,10 +4935,15 @@ static int rtl8125_enable_eee(struct rtl8125_private *tp)
                 break;
         case CFG_METHOD_4:
         case CFG_METHOD_5:
+                RTL_W16(tp, EEE_TXIDLE_TIMER_8125, eee->tx_lpi_timer);
+
                 SetMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
 
-                SetEthPhyOcpBit(tp, 0xA5D0, tp->eee_adv_t);
-                ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+                SetEthPhyOcpBit(tp, 0xA5D0, eee_adv_t);
+                if (eee->advertised & SUPPORTED_2500baseX_Full)
+                        SetEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+                else
+                        ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
 
                 ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
                 ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
@@ -5045,10 +5057,11 @@ static int rtl_nway_reset(struct net_device *dev)
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
 static int
-rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *eee)
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
 {
         struct rtl8125_private *tp = netdev_priv(net);
-        u32 lp, adv, supported = 0;
+        struct ethtool_eee *eee = &tp->eee;
+        u32 lp, adv, tx_lpi_timer, supported = 0;
         unsigned long flags;
         u16 val;
 
@@ -5060,8 +5073,9 @@ rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *eee)
         }
 
         /* Get Supported EEE */
-        val = mdio_direct_read_phy_ocp(tp, 0xA5C4);
-        supported = mmd_eee_cap_to_ethtool_sup_t(val);
+        //val = mdio_direct_read_phy_ocp(tp, 0xA5C4);
+        //supported = mmd_eee_cap_to_ethtool_sup_t(val);
+        supported = eee->supported;
 
         /* Get advertisement EEE */
         val = mdio_direct_read_phy_ocp(tp, 0xA5D0);
@@ -5071,25 +5085,33 @@ rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *eee)
         val = mdio_direct_read_phy_ocp(tp, 0xA5D2);
         lp = mmd_eee_adv_to_ethtool_adv_t(val);
 
+        /* Get EEE Tx LPI timer*/
+        tx_lpi_timer = RTL_R16(tp, EEE_TXIDLE_TIMER_8125);
+
         val = rtl8125_mac_ocp_read(tp, 0xE040);
         val &= BIT_1 | BIT_0;
 
         spin_unlock_irqrestore(&tp->lock, flags);
 
-        eee->eee_enabled = !!val;
-        eee->eee_active = !!(supported & adv & lp);
-        eee->supported = supported;
-        eee->advertised = adv;
-        eee->lp_advertised = lp;
+        edata->eee_enabled = !!val;
+        edata->eee_active = !!(supported & adv & lp);
+        edata->supported = supported;
+        edata->advertised = adv;
+        edata->lp_advertised = lp;
+        edata->tx_lpi_enabled = edata->eee_enabled;
+        edata->tx_lpi_timer = tx_lpi_timer;
 
         return 0;
 }
 
 static int
-rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *eee)
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
 {
         struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        u32 advertising;
         unsigned long flags;
+        int rc = 0;
 
         if (!HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp) ||
             tp->DASH)
@@ -5098,24 +5120,71 @@ rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *eee)
         spin_lock_irqsave(&tp->lock, flags);
 
         if (unlikely(tp->rtk_enable_diag)) {
-                spin_unlock_irqrestore(&tp->lock, flags);
-                return -EBUSY;
+                dev_printk(KERN_WARNING, &tp->pci_dev->dev, "Diag Enabled\n");
+                rc = -EBUSY;
+                goto exit_unlock;
+        }
+
+        if (tp->autoneg != AUTONEG_ENABLE) {
+                dev_printk(KERN_WARNING, &tp->pci_dev->dev, "EEE requires autoneg\n");
+                rc = -EINVAL;
+                goto exit_unlock;
         }
 
-        tp->eee_enabled = eee->eee_enabled;
-        tp->eee_adv_t = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+        if (edata->tx_lpi_enabled) {
+                if (edata->tx_lpi_timer > tp->max_jumbo_frame_size ||
+                    edata->tx_lpi_timer < ETH_MIN_MTU) {
+                        dev_printk(KERN_WARNING, &tp->pci_dev->dev, "Valid LPI timer range is %d to %d. \n",
+                                   ETH_MIN_MTU, tp->max_jumbo_frame_size);
+                        rc = -EINVAL;
+                        goto exit_unlock;
+                }
+        }
 
-        if (tp->eee_enabled) {
+        advertising = tp->advertising;
+        if (!edata->advertised) {
+                edata->advertised = advertising & eee->supported;
+        } else if (edata->advertised & ~advertising) {
+                dev_printk(KERN_WARNING, &tp->pci_dev->dev, "EEE advertised %x must be a subset of autoneg advertised speeds %x\n",
+                           edata->advertised, advertising);
+                rc = -EINVAL;
+                goto exit_unlock;
+        }
+
+        if (edata->advertised & ~eee->supported) {
+                dev_printk(KERN_WARNING, &tp->pci_dev->dev, "EEE advertised %x must be a subset of support %x\n",
+                           edata->advertised, eee->supported);
+                rc = -EINVAL;
+                goto exit_unlock;
+        }
+
+        //tp->eee.eee_enabled = edata->eee_enabled;
+        //tp->eee_adv_t = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);
+
+        dev_printk(KERN_WARNING, &tp->pci_dev->dev, "EEE tx_lpi_timer %x must be a subset of support %x\n",
+                   edata->tx_lpi_timer, eee->tx_lpi_timer);
+
+        eee->advertised = edata->advertised;
+        eee->tx_lpi_enabled = edata->tx_lpi_enabled;
+        eee->tx_lpi_timer = edata->tx_lpi_timer;
+        eee->eee_enabled = edata->eee_enabled;
+
+        if (eee->eee_enabled)
                 rtl8125_enable_eee(tp);
-        } else {
+        else
                 rtl8125_disable_eee(tp);
-        }
 
         spin_unlock_irqrestore(&tp->lock, flags);
 
         rtl_nway_reset(net);
 
-        return 0;
+        return rc;
+
+exit_unlock:
+
+        spin_unlock_irqrestore(&tp->lock, flags);
+
+        return rc;
 }
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
 
@@ -8527,9 +8596,6 @@ rtl8125_hw_phy_config_8125a_2(struct net_device *dev)
                                );
 
 
-        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, dev->mtu + ETH_HLEN + 0x20);
-
-
         mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80A2);
         mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0153);
         mdio_direct_write_phy_ocp(tp, 0xB87C, 0x809C);
@@ -8943,9 +9009,6 @@ rtl8125_hw_phy_config_8125b_1(struct net_device *dev)
         mdio_direct_write_phy_ocp(tp, 0xB87E, 0x050E);
 
 
-        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, dev->mtu + ETH_HLEN + 0x20);
-
-
         mdio_direct_write_phy_ocp(tp, 0xA436, 0x816C);
         mdio_direct_write_phy_ocp(tp, 0xA438, 0xC4A0);
         mdio_direct_write_phy_ocp(tp, 0xA436, 0x8170);
@@ -9135,7 +9198,7 @@ rtl8125_hw_phy_config_8125b_2(struct net_device *dev)
                                );
 
 
-        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, dev->mtu + ETH_HLEN + 0x20);
+        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, tp->eee.tx_lpi_timer);
 
         mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F5);
         mdio_direct_write_phy_ocp(tp, 0xB87E, 0x760E);
@@ -9303,7 +9366,7 @@ rtl8125_hw_phy_config(struct net_device *dev)
         rtl8125_mdio_write(tp, 0x1F, 0x0000);
 
         if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
-                if (tp->eee_enabled == 1)
+                if (tp->eee.eee_enabled)
                         rtl8125_enable_eee(tp);
                 else
                         rtl8125_disable_eee(tp);
@@ -9448,6 +9511,10 @@ rtl8125_init_software_variable(struct net_device *dev)
 
         rtl8125_get_bios_setting(dev);
 
+#ifdef ENABLE_LIB_SUPPORT
+        tp->ring_lib_enabled = 1;
+#endif
+
         switch (tp->mcfg) {
         case CFG_METHOD_2:
         case CFG_METHOD_3:
@@ -9819,8 +9886,22 @@ rtl8125_init_software_variable(struct net_device *dev)
         dev->min_mtu = ETH_MIN_MTU;
         dev->max_mtu = tp->max_jumbo_frame_size;
 #endif //LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
-        tp->eee_enabled = eee_enable;
-        tp->eee_adv_t = MDIO_EEE_1000T | MDIO_EEE_100TX;
+
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                struct ethtool_eee *eee = &tp->eee;
+
+                eee->eee_enabled = eee_enable;
+                eee->supported  = SUPPORTED_100baseT_Full |
+                                  SUPPORTED_1000baseT_Full;
+                switch (tp->mcfg) {
+                case CFG_METHOD_4:
+                case CFG_METHOD_5:
+                        eee->supported |= SUPPORTED_2500baseX_Full;
+                        break;
+                }
+                eee->advertised = mmd_eee_adv_to_ethtool_adv_t(MDIO_EEE_1000T | MDIO_EEE_100TX);
+                tp->eee.tx_lpi_timer = dev->mtu + ETH_HLEN + 0x20;
+        }
 
         tp->ptp_master_mode = enable_ptp_master_mode;
 }
@@ -13151,14 +13232,21 @@ __be16 get_protocol(struct sk_buff *skb)
 static inline
 u8 rtl8125_get_l4_protocol(struct sk_buff *skb)
 {
+        int no = skb_network_offset(skb);
+        struct ipv6hdr *i6h, _i6h;
+        struct iphdr *ih, _ih;
         u8 ip_protocol = IPPROTO_RAW;
 
         switch (get_protocol(skb)) {
         case  __constant_htons(ETH_P_IP):
-                ip_protocol = ip_hdr(skb)->protocol;
+                ih = skb_header_pointer(skb, no, sizeof(_ih), &_ih);
+                if (ih)
+                        ip_protocol = ih->protocol;
                 break;
         case  __constant_htons(ETH_P_IPV6):
-                ip_protocol = ipv6_hdr(skb)->nexthdr;
+                i6h = skb_header_pointer(skb, no, sizeof(_i6h), &_i6h);
+                if (i6h)
+                        ip_protocol = i6h->nexthdr;
                 break;
         }
 
-- 
2.20.1

